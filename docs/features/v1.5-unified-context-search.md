# Recherche UnifiÃ©e de Contexte - SpÃ©cifications V1.5

**Date:** 2026-01-14  
**Auteur:** Sally (UX Designer)  
**Statut:** DocumentÃ© pour V1.5  
**PrÃ©requis:** Migration SQLite (V1.5)

---

## ProblÃ¨me Actuel

L'interface actuelle utilise des **onglets sÃ©parÃ©s** pour chaque catÃ©gorie de contexte (Personnages, Lieux, Objets, EspÃ¨ces, CommunautÃ©s). Pour sÃ©lectionner des Ã©lÃ©ments de catÃ©gories diffÃ©rentes, l'utilisateur doit :

1. Naviguer vers l'onglet "Personnages"
2. SÃ©lectionner les personnages
3. Naviguer vers l'onglet "Lieux"
4. SÃ©lectionner les lieux
5. RÃ©pÃ©ter pour chaque catÃ©gorie

**Friction identifiÃ©e :**
- Changements d'onglets rÃ©pÃ©titifs (3-5 clics pour une configuration complÃ¨te)
- Recherche sÃ©quentielle (impossible de chercher "LÃ©viathan" et voir tous les rÃ©sultats d'un coup)
- Mental model fragmentÃ© (contexte = ensemble cohÃ©rent, pas des catÃ©gories isolÃ©es)

**ProblÃ¨me technique sous-jacent :**
- Recherche actuelle = chargement de tous les JSON + parsing + filter (LENT : 2-5 secondes)
- Pas d'indexation pour recherche rapide
- MÃ©tadonnÃ©es riches disponibles mais pas exploitables efficacement

---

## Solution ProposÃ©e : Vue UnifiÃ©e avec Recherche Rapide

### Vision UX

**Une seule vue** remplaÃ§ant les onglets, avec :
- **Recherche unifiÃ©e** qui cherche dans toutes les catÃ©gories simultanÃ©ment
- **Filtres combinables** par type (Personnages, Lieux, etc.) et par mÃ©tadonnÃ©es (RÃ©gion, Sprint, etc.)
- **RÃ©sultats hiÃ©rarchisÃ©s** : correspondances exactes dans le nom en premier, puis correspondances dans le contenu
- **SÃ©lection multi-catÃ©gories** rapide dans une seule vue

### Exemple Mental

```
â”Œâ”€ CONTEXTE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ğŸ” Rechercher... (Ctrl+K)                      â”‚
â”‚                                                â”‚
â”‚ Filtres:                                       â”‚
â”‚ [Tous] [ğŸ‘¤ Persos] [ğŸ“ Lieux] [ğŸ—¡ï¸ Objets]     â”‚
â”‚ [ğŸ§¬ EspÃ¨ces] [ğŸ›ï¸ Commu] [â­ Favoris]          â”‚
â”‚                                                â”‚
â”‚ â”Œâ”€ RÃ©sultats (7 sÃ©lectionnÃ©s) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ â˜‘ ğŸ‘¤ Seigneuresse UresÃ¤ir                â”‚ â”‚
â”‚ â”‚      LÃ©viathan Â· Personnage Â· 2.1K       â”‚ â”‚
â”‚ â”‚                                            â”‚ â”‚
â”‚ â”‚ â˜‘ ğŸ‘¤ Voknir Esh'Maradel                  â”‚ â”‚
â”‚ â”‚      LÃ©viathan Â· Personnage Â· 1.8K       â”‚ â”‚
â”‚ â”‚                                            â”‚ â”‚
â”‚ â”‚ â˜ ğŸ“ LÃ©viathan pÃ©trifiÃ©                  â”‚ â”‚
â”‚ â”‚      RÃ©gion Â· 4.3K tokens                â”‚ â”‚
â”‚ â”‚                                            â”‚ â”‚
â”‚ â”‚ â˜‘ ğŸ“ MarchÃ© Noir (sous-lieu)             â”‚ â”‚
â”‚ â”‚      LÃ©viathan Â· Lieu Â· 890 tokens       â”‚ â”‚
â”‚ â”‚                                            â”‚ â”‚
â”‚ â”‚ ... (scroll pour plus)                    â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                â”‚
â”‚ ğŸ“Š Total: 28.4K / 128K tokens (22%)           â”‚
â”‚ [SÃ©lections actives (7)] [Tout effacer]       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Architecture Technique

### PrÃ©requis : SQLite (V1.5)

La migration SQLite prÃ©vue pour V1.5 permettra :
- Indexation native avec FTS5 (Full-Text Search)
- RequÃªtes rapides (<200ms mÃªme sur grandes bases)
- Persistance structurÃ©e
- Fondation pour d'autres features (historique, analytics, etc.)

### Schema SQLite

#### Table `gdd_items`

Table principale contenant tous les Ã©lÃ©ments du GDD indexÃ©s.

```sql
CREATE TABLE gdd_items (
    id TEXT PRIMARY KEY,                    -- UUID ou nom normalisÃ©
    name TEXT NOT NULL,                     -- Nom de l'Ã©lÃ©ment
    type TEXT NOT NULL,                     -- 'character', 'location', 'item', 'species', 'community'
    category TEXT,                          -- CatÃ©gorie (ex: "Personnages", "Lieux")
    region TEXT,                            -- RÃ©gion associÃ©e (ex: "LÃ©viathan pÃ©trifiÃ©")
    sprint TEXT,                            -- Sprint (ex: "Sprint 2")
    metadata_json TEXT,                     -- JSON avec toutes les mÃ©tadonnÃ©es (Alias, EspÃ¨ce, etc.)
    full_text TEXT,                         -- Texte complet indexable (RÃ©sumÃ© + sections clÃ©s)
    token_count INTEGER,                    -- Nombre de tokens estimÃ©
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_gdd_items_type ON gdd_items(type);
CREATE INDEX idx_gdd_items_region ON gdd_items(region);
CREATE INDEX idx_gdd_items_sprint ON gdd_items(sprint);
CREATE INDEX idx_gdd_items_category ON gdd_items(category);
```

#### Table FTS5 pour recherche full-text

```sql
CREATE VIRTUAL TABLE gdd_items_fts USING fts5(
    name,
    alias,                                  -- Extrait de metadata_json
    full_text,
    content='gdd_items',
    content_rowid='rowid'
);
```

**Trigger pour maintenir l'index FTS :**
```sql
CREATE TRIGGER gdd_items_fts_insert AFTER INSERT ON gdd_items BEGIN
    INSERT INTO gdd_items_fts(rowid, name, alias, full_text)
    VALUES (new.rowid, new.name, json_extract(new.metadata_json, '$.Alias'), new.full_text);
END;

CREATE TRIGGER gdd_items_fts_delete AFTER DELETE ON gdd_items BEGIN
    INSERT INTO gdd_items_fts(gdd_items_fts, rowid, name, alias, full_text)
    VALUES('delete', old.rowid, old.name, json_extract(old.metadata_json, '$.Alias'), old.full_text);
END;

CREATE TRIGGER gdd_items_fts_update AFTER UPDATE ON gdd_items BEGIN
    INSERT INTO gdd_items_fts(gdd_items_fts, rowid, name, alias, full_text)
    VALUES('delete', old.rowid, old.name, json_extract(old.metadata_json, '$.Alias'), old.full_text);
    INSERT INTO gdd_items_fts(rowid, name, alias, full_text)
    VALUES (new.rowid, new.name, json_extract(new.metadata_json, '$.Alias'), new.full_text);
END;
```

#### Table `user_favorites` (optionnel V1.5)

```sql
CREATE TABLE user_favorites (
    user_id TEXT NOT NULL,
    item_id TEXT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (user_id, item_id),
    FOREIGN KEY (item_id) REFERENCES gdd_items(id)
);
```

### Service Backend : `SearchIndexService`

**ResponsabilitÃ© :** Indexer et rechercher dans le GDD de maniÃ¨re efficace.

**MÃ©thodes principales :**
```python
class SearchIndexService:
    def rebuild_index(self) -> None:
        """Rebuild l'index complet depuis les fichiers GDD JSON."""
        # 1. Parcourir tous les fichiers GDD
        # 2. Extraire mÃ©tadonnÃ©es + texte indexable
        # 3. InsÃ©rer/mettre Ã  jour dans SQLite
        # AppelÃ© au dÃ©marrage de l'app ou quand GDD change
        
    def search(
        self,
        query: str,
        filters: Optional[Dict[str, Any]] = None,
        limit: int = 50
    ) -> List[SearchResult]:
        """Recherche dans l'index avec filtres."""
        # Utilise FTS5 pour recherche rapide
        # Applique filtres (type, rÃ©gion, sprint, etc.)
        # Trie par pertinence (exact match dans nom > contenu)
        
    def get_by_id(self, item_id: str) -> Optional[GDDItem]:
        """RÃ©cupÃ¨re un Ã©lÃ©ment par ID."""
        
    def get_favorites(self, user_id: str) -> List[GDDItem]:
        """RÃ©cupÃ¨re les favoris de l'utilisateur."""
```

**Rebuild Index :**
- **Quand :** Au dÃ©marrage de l'app (si index absent ou obsolÃ¨te)
- **Performance cible :** <5 secondes pour indexer ~2000 Ã©lÃ©ments
- **IncrÃ©mentiel :** DÃ©tecter changements dans fichiers GDD (timestamp) et mettre Ã  jour uniquement les Ã©lÃ©ments modifiÃ©s

**Recherche :**
- **Performance cible :** <200ms pour une recherche avec filtres
- **Pertinence :** 
  1. Exact match dans `name` (prioritÃ© maximale)
  2. Match dans `alias` (prioritÃ© haute)
  3. Match dans `full_text` (prioritÃ© normale)
  4. Fuzzy match (si pas de rÃ©sultats exacts)

### API Endpoints

#### `GET /api/v1/context/search`

Recherche unifiÃ©e dans toutes les catÃ©gories.

**Query Parameters :**
- `q` (string, required) : Terme de recherche
- `types` (string[], optional) : Filtrer par types (`character`, `location`, `item`, etc.)
- `regions` (string[], optional) : Filtrer par rÃ©gions
- `sprints` (string[], optional) : Filtrer par sprints
- `favorites_only` (boolean, optional) : Uniquement favoris
- `limit` (integer, optional, default: 50) : Nombre max de rÃ©sultats

**Response :**
```json
{
  "results": [
    {
      "id": "seigneuresse-uresair",
      "name": "Seigneuresse UresÃ¤ir",
      "type": "character",
      "category": "Personnages",
      "region": "LÃ©viathan pÃ©trifiÃ©",
      "sprint": "Sprint 2",
      "token_count": 2100,
      "preview": "PremiÃ¨re rencontre in-game...",
      "match_reason": "exact_name" // "exact_name", "alias", "content"
    }
  ],
  "total": 15,
  "query": "uresair",
  "filters_applied": {
    "types": ["character"],
    "regions": ["LÃ©viathan pÃ©trifiÃ©"]
  }
}
```

#### `GET /api/v1/context/items/{id}`

RÃ©cupÃ¨re les dÃ©tails complets d'un Ã©lÃ©ment (pour prÃ©visualisation dans tooltip).

**Response :** MÃªme structure qu'un Ã©lÃ©ment GDD complet (depuis JSON).

#### `POST /api/v1/context/favorites/{id}`

Ajoute un Ã©lÃ©ment aux favoris.

#### `DELETE /api/v1/context/favorites/{id}`

Retire un Ã©lÃ©ment des favoris.

---

## SpÃ©cifications UX DÃ©taillÃ©es

*(Ã€ crÃ©er en V1.5 avec wireframes Excalidraw)*

### Composants UI

1. **Barre de recherche** : Input avec placeholder "Rechercher des personnages, lieux, objets..." (Ctrl+K)
2. **Chips de filtres** : Filtres combinables (Type, RÃ©gion, Sprint, Favoris)
3. **Liste de rÃ©sultats** : Items avec checkbox, icÃ´ne, nom, mÃ©tadonnÃ©es, token count
4. **Footer** : Total tokens sÃ©lectionnÃ©s, actions (SÃ©lections actives, Tout effacer)

### Interactions

- **Recherche en temps rÃ©el** : RÃ©sultats affichÃ©s pendant la frappe (debounce 300ms)
- **Keyboard navigation** : â†‘â†“ pour naviguer, Espace pour sÃ©lectionner, Enter pour prÃ©visualiser
- **Filtres combinables** : Plusieurs filtres actifs simultanÃ©ment
- **Tooltip au hover** : AperÃ§u dÃ©taillÃ© de l'Ã©lÃ©ment (sans charger la page complÃ¨te)

### HiÃ©rarchisation des RÃ©sultats

**Ordre de tri :**
1. **Correspondances exactes dans le nom** (mis en valeur visuellement : gras, couleur)
2. **Correspondances dans l'alias**
3. **Correspondances dans le contenu**
4. **Favoris** (toujours affichÃ©s en haut si match partiel)

---

## Migration depuis l'Ancienne Interface

### Backward Compatibility

L'ancienne interface (onglets sÃ©parÃ©s) peut coexister avec la nouvelle :
- **Option A** : Toggle "Vue unifiÃ©e" / "Vue classique" (migration progressive)
- **Option B** : Remplacer complÃ¨tement (cleaner, mais breaking change)

**Recommandation :** Option B (remplacement complet) car la nouvelle interface est strictement meilleure.

### DonnÃ©es Existantes

- **SÃ©lections en cours** : Migrer automatiquement (si session active, prÃ©server les sÃ©lections)
- **Favoris** : Nouveau systÃ¨me (vide au dÃ©part, utilisateurs peuvent ajouter leurs favoris)

---

## Estimation

### Backend

- **Schema SQLite + FTS5** : 2h
- **SearchIndexService** : 4h (rebuild index + recherche)
- **API Endpoints** : 2h
- **Tests** : 2h
- **Total Backend :** ~10h (~1.25 jours)

### Frontend

- **Composants UI** : 6h (recherche, filtres, liste)
- **IntÃ©gration API** : 2h
- **Keyboard navigation** : 2h
- **Tests** : 2h
- **Total Frontend :** ~12h (~1.5 jours)

### Total

**~22h (~2.75 jours)** de dÃ©veloppement

---

## DÃ©pendances V1.5

- Migration SQLite complÃ¨te (prÃ©requis technique)
- Service d'authentification (pour favoris par utilisateur)
- Infrastructure de recherche (FTS5, indexation)

---

## Notes Techniques

### Performance

- **Index initial** : <5 secondes pour ~2000 Ã©lÃ©ments
- **Recherche** : <200ms avec filtres
- **Rebuild incrÃ©mental** : DÃ©tection de changements (timestamp fichiers) + update uniquement modifiÃ©s

### ScalabilitÃ©

- **Limite actuelle** : ~5000 Ã©lÃ©ments (performance acceptable)
- **Au-delÃ ** : Partitioning par type ou rÃ©gion (optimisation future)

### SÃ©curitÃ©

- **Favoris** : Scoped par utilisateur (isolation des donnÃ©es)
- **Recherche** : Pas de donnÃ©es sensibles dans l'index (uniquement contenu GDD public)

---

## RÃ©fÃ©rences

- PRD : `_bmad-output/planning-artifacts/prd.md`
- SpÃ©cifications UX V1.0 : `docs/features/v1.0-ux-specs.md`
- Architecture API : `docs/architecture-api.md`
