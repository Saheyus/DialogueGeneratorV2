# DialogueGenerator/ui/main_window.py
import json
import asyncio # Added for asynchronous tasks
from PySide6.QtWidgets import (QMainWindow, QWidget, QVBoxLayout, QHBoxLayout,
                               QLabel, QComboBox, QTextEdit, QSplitter,
                               QListWidget, QListWidgetItem, QTreeView, QAbstractItemView, QLineEdit,
                               QGroupBox, QHeaderView, QPushButton, QTabWidget, QApplication, QGridLayout, QCheckBox)
from PySide6.QtGui import QStandardItemModel, QStandardItem, QPalette, QColor, QAction, QCloseEvent
from PySide6.QtCore import Qt, QSize, QTimer, QItemSelectionModel, QSortFilterProxyModel, QRegularExpression
import sys
import os
from pathlib import Path # Added for path management
import webbrowser # Added to open the configuration file

# Import new modules
from prompt_engine import PromptEngine
from llm_client import OpenAIClient, DummyLLMClient
from .generation_panel import GenerationPanel # Added import

# Path to the DialogueGenerator directory
DIALOGUE_GENERATOR_DIR = Path(__file__).parent.parent
UI_SETTINGS_FILE = DIALOGUE_GENERATOR_DIR / "ui_settings.json" # File to save UI settings
CONTEXT_CONFIG_FILE_PATH = DIALOGUE_GENERATOR_DIR / "context_config.json" # Path to context_config.json

# Ensure the parent directory of DialogueGenerator (project root) is in PYTHONPATH
PROJECT_ROOT = DIALOGUE_GENERATOR_DIR.parent
if str(PROJECT_ROOT) not in sys.path:
    sys.path.append(str(PROJECT_ROOT))

# Import ContextBuilder after adjusting the path
from DialogueGenerator.context_builder import ContextBuilder

# For logging
import logging
logger = logging.getLogger(__name__)

def populate_tree_view(model: QStandardItemModel, parent_item: QStandardItem, data: dict | list):
    """Recursively populates the QTreeView with data from a dictionary or list."""
    if isinstance(data, dict):
        for key, value in data.items():
            key_item = QStandardItem(str(key))
            key_item.setEditable(False)
            
            if isinstance(value, (dict, list)):
                # The key is a parent row, children will be key-value pairs of the nested dict/list
                parent_item.appendRow(key_item) 
                populate_tree_view(model, key_item, value) # Recursive call for children
            else:
                # Simple key and value on the same row, in different columns
                value_item = QStandardItem(str(value))
                value_item.setEditable(False)
                parent_item.appendRow([key_item, value_item]) 

    elif isinstance(data, list):
        for index, value in enumerate(data):
            # The index is displayed as a "key" for list items
            index_item = QStandardItem(f"[{index}]")
            index_item.setEditable(False)

            if isinstance(value, (dict, list)):
                parent_item.appendRow(index_item)
                populate_tree_view(model, index_item, value)
            else:
                value_item = QStandardItem(str(value))
                value_item.setEditable(False)
                parent_item.appendRow([index_item, value_item])

class MainWindow(QMainWindow):
    """Main window of the DialogueGenerator application.

    This class manages the user interface for context selection,
    configuration of generation parameters, display of prompts
    and dialogue variants generated by an LLM.
    """
    def __init__(self, context_builder: ContextBuilder):
        """Initializes the MainWindow.

        Args:
            context_builder: Instance of ContextBuilder to access GDD data.
        """
        super().__init__()
        self.context_builder = context_builder
        self.prompt_engine = PromptEngine()
        
        # --- LLM Client Choice ---
        # For now, OpenAIClient is used by default.
        # Ensure the OPENAI_API_KEY environment variable is set.
        try:
            self.llm_client = OpenAIClient(model="gpt-4o-mini") # Using gpt-4o-mini
            if not self.llm_client.api_key:
                print("WARNING: OpenAI API key not found. Switching to DummyLLMClient.")
                self.llm_client = DummyLLMClient()
        except Exception as e:
            print(f"Error initializing OpenAIClient: {e}. Switching to DummyLLMClient.")
            self.llm_client = DummyLLMClient()

        self.setWindowTitle("DialogueGenerator IA - Context Builder")
        self.setGeometry(100, 100, 1800, 900) # A bit wider for tabs

        self._create_actions() # Create actions before creating menus
        self._create_menu_bar() # Create the main menu bar

        # Instantiate GenerationPanel before setup_ui so its widgets are available
        self.generation_panel = GenerationPanel(self)

        self.setup_ui() # This now also sets initial objectNames for comboboxes
        
        # Connect signals AFTER setup_ui and BEFORE load_initial_data / _load_ui_settings
        # This ensures they are connected for normal operation but can be managed during loading.
        # Signals for widgets now in GenerationPanel:
        self.generation_panel.character_a_combo.currentIndexChanged.connect(self._update_token_estimation_and_prompt_display)
        self.generation_panel.character_b_combo.currentIndexChanged.connect(self._update_token_estimation_and_prompt_display)
        self.generation_panel.scene_region_combo.currentIndexChanged.connect(self._on_scene_region_changed)
        self.generation_panel.scene_region_combo.currentIndexChanged.connect(self._update_token_estimation_and_prompt_display)
        self.generation_panel.scene_sub_location_combo.currentIndexChanged.connect(self._update_token_estimation_and_prompt_display)
        self.generation_panel.include_dialogue_type_checkbox.stateChanged.connect(self._update_token_estimation_and_prompt_display)
        self.generation_panel.user_instruction_input.textChanged.connect(self._update_token_estimation_and_prompt_display)
        self.generation_panel.generate_dialogue_button.clicked.connect(self._on_generate_dialogue_button_clicked)
        self.generation_panel.suggest_linked_elements_button.clicked.connect(self._on_suggest_linked_elements_clicked)

        if self.context_builder:
            self.load_initial_data()

        # Load UI settings after populating widgets
        self._load_ui_settings() 

        # Initialize timer for context/token update (if necessary)
        self.token_update_timer = QTimer(self)
        self.token_update_timer.setSingleShot(True)
        self.token_update_timer.timeout.connect(self._update_token_estimation_and_prompt_display)
        self.token_update_timer.start(500) # Start once after loading

    def _create_actions(self):
        """Creates actions for the menus."""
        self.restore_selections_action = QAction("Restore selections on startup", self)
        self.restore_selections_action.setCheckable(True)
        self.restore_selections_action.setChecked(True) # Default
        # Logic for saving/loading this state will be in _save/_load_ui_settings

        self.edit_context_config_action = QAction("&Edit Context Configuration...", self)
        self.edit_context_config_action.triggered.connect(self._open_context_config_file)

        self.exit_action = QAction("&Exit", self)
        self.exit_action.triggered.connect(self.close)

    def _create_menu_bar(self):
        """Creates the main menu bar with application options."""
        menu_bar = self.menuBar()

        # File Menu (or Options)
        options_menu = menu_bar.addMenu("&Options")
        options_menu.addAction(self.restore_selections_action)
        options_menu.addSeparator()
        options_menu.addAction(self.edit_context_config_action) 
        options_menu.addSeparator()
        options_menu.addAction(self.exit_action)

    def _open_context_config_file(self):
        """Opens the context configuration file (context_config.json)
        in the system's default editor.
        """
        if CONTEXT_CONFIG_FILE_PATH.exists():
            try:
                webbrowser.open(os.path.realpath(CONTEXT_CONFIG_FILE_PATH))
                logger.info(f"Attempting to open {CONTEXT_CONFIG_FILE_PATH}")
            except Exception as e:
                logger.error(f"Could not open {CONTEXT_CONFIG_FILE_PATH}: {e}")
                self.statusBar().showMessage(f"Error: Could not open configuration file: {e}")
        else:
            logger.warning(f"Configuration file {CONTEXT_CONFIG_FILE_PATH} does not exist.")
            self.statusBar().showMessage("Error: Context configuration file not found.")

    def _create_list_section_ui(self, section_label_text: str, list_object_name_prefix: str) -> tuple[QListWidget, QLineEdit, QLabel]:
        """Helper function to create a section with a label, filter, and list widget."""
        label = QLabel(section_label_text)
        filter_edit = QLineEdit()
        filter_edit.setPlaceholderText(f"Filter {section_label_text.lower().replace(':', '')}...")
        list_widget = QListWidget()
        list_widget.setObjectName(f"{list_object_name_prefix}_list")
        
        # Connect filter_edit.textChanged to self._filter_list_widget
        # The lambda captures list_widget, label, and section_label_text for use in _filter_list_widget
        filter_edit.textChanged.connect(
            lambda text, lw=list_widget, lbl=label, original_text=section_label_text: 
            self._filter_list_widget(text, lw, lbl, original_text)
        )
        return list_widget, filter_edit, label

    def _create_left_selection_panel(self) -> QWidget:
        """Creates and configures the left selection panel.

        This panel contains filterable lists for characters, locations, items,
        species, communities, and dialogue examples.

        Returns:
            QWidget: The widget containing the left selection panel.
        """
        left_panel_content_widget = QWidget() # Renamed from left_scroll_area_content
        left_panel_layout = QVBoxLayout(left_panel_content_widget)
        left_panel_layout.setSpacing(10)

        # Using the helper to create each list section
        self.character_list, self.character_filter_edit, self.character_section_label = self._create_list_section_ui("Characters:", "character")
        left_panel_layout.addWidget(self.character_section_label)
        left_panel_layout.addWidget(self.character_filter_edit)
        left_panel_layout.addWidget(self.character_list)
        self.character_list.itemClicked.connect(lambda item_widget: self._on_explorer_list_item_clicked(self.character_list, self.context_builder.characters if self.context_builder else [], "Character", item_widget))

        self.location_list, self.location_filter_edit, self.location_section_label = self._create_list_section_ui("Locations:", "location")
        left_panel_layout.addWidget(self.location_section_label)
        left_panel_layout.addWidget(self.location_filter_edit)
        left_panel_layout.addWidget(self.location_list)
        self.location_list.itemClicked.connect(lambda item_widget: self._on_explorer_list_item_clicked(self.location_list, self.context_builder.locations if self.context_builder else [], "Location", item_widget))
        
        self.item_list, self.item_filter_edit, self.item_section_label = self._create_list_section_ui("Items:", "item")
        left_panel_layout.addWidget(self.item_section_label)
        left_panel_layout.addWidget(self.item_filter_edit)
        left_panel_layout.addWidget(self.item_list)
        self.item_list.itemClicked.connect(lambda item_widget: self._on_explorer_list_item_clicked(self.item_list, self.context_builder.items if self.context_builder else [], "Item", item_widget))

        self.species_list, self.species_filter_edit, self.species_section_label = self._create_list_section_ui("Species:", "species")
        left_panel_layout.addWidget(self.species_section_label)
        left_panel_layout.addWidget(self.species_filter_edit)
        left_panel_layout.addWidget(self.species_list)
        self.species_list.itemClicked.connect(lambda item_widget: self._on_explorer_list_item_clicked(self.species_list, self.context_builder.species if self.context_builder else [], "Species", item_widget))

        self.communities_list, self.communities_filter_edit, self.communities_section_label = self._create_list_section_ui("Communities:", "communities")
        left_panel_layout.addWidget(self.communities_section_label)
        left_panel_layout.addWidget(self.communities_filter_edit)
        left_panel_layout.addWidget(self.communities_list)
        self.communities_list.itemClicked.connect(lambda item_widget: self._on_explorer_list_item_clicked(self.communities_list, self.context_builder.communities if self.context_builder else [], "Community", item_widget))
        
        self.dialogue_examples_list, self.dialogue_examples_filter_edit, self.dialogue_examples_section_label = self._create_list_section_ui("Dialogue Examples:", "dialogues") # Renamed dialogues_list
        left_panel_layout.addWidget(self.dialogue_examples_section_label)
        left_panel_layout.addWidget(self.dialogue_examples_filter_edit)
        left_panel_layout.addWidget(self.dialogue_examples_list)
        self.dialogue_examples_list.itemClicked.connect(lambda item_widget: self._on_explorer_list_item_clicked(self.dialogue_examples_list, self.context_builder.dialogue_examples if self.context_builder else [], "Dialogue Example", item_widget, name_key_priority=["Nom", "Titre", "ID"])) # Updated to use new name
        
        # left_container_widget is now left_panel_content_widget itself
        left_panel_content_widget.setMinimumWidth(300)
        left_panel_content_widget.setMaximumWidth(400)
        return left_panel_content_widget

    def _create_center_details_panel(self) -> QWidget:
        """Creates and configures the center panel for displaying details.

        This panel uses a QTreeView to present detailed information
        of the item selected in the left lists.

        Returns:
            QWidget: The widget containing the details panel.
        """
        details_panel_widget = QWidget() # Renamed from details_panel
        details_panel_layout = QVBoxLayout(details_panel_widget) # Renamed from details_layout
        self.details_view_label = QLabel("Selected Item Details:") # Renamed from details_label
        self.details_tree_view = QTreeView()
        self.details_tree_view.setEditTriggers(QAbstractItemView.NoEditTriggers)
        self.details_tree_model = QStandardItemModel()
        self.details_tree_model.setHorizontalHeaderLabels(["Property", "Value"]) # Translated
        self.details_tree_view.setModel(self.details_tree_model)
        self.details_tree_view.header().setVisible(True)
        
        details_panel_layout.addWidget(self.details_view_label)
        details_panel_layout.addWidget(self.details_tree_view)
        return details_panel_widget # Renamed

    def setup_ui(self):
        """Configures the main user interface of the window.

        Initializes the left, center, and right panels, assembles them in a
        splitter, and adds them to the central widget of the window.
        """
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        main_layout = QHBoxLayout(central_widget)

        left_panel = self._create_left_selection_panel()
        center_panel = self._create_center_details_panel()
        right_panel = self.generation_panel
        
        self.main_splitter = QSplitter(Qt.Horizontal) # Renamed from self.splitter
        self.main_splitter.addWidget(left_panel) 
        self.main_splitter.addWidget(center_panel)
        self.main_splitter.addWidget(right_panel)
        
        self.main_splitter.setStretchFactor(0, 1) 
        self.main_splitter.setStretchFactor(1, 2) 
        self.main_splitter.setStretchFactor(2, 2) 

        main_layout.addWidget(self.main_splitter)
        
        self.statusBar().showMessage("Ready.")
        self.active_list_widget_for_details = None # This seems okay, refers to a QListWidget instance

    def _get_current_context_selections(self) -> dict: # Renamed
        """Retrieves all user selections relevant for context building.

        Returns:
            dict: A dictionary with item categories (characters, locations, etc.)
                  and a list of selected item names for each category.
        """
        ignore_values = {"-- None --", "<None>", "-- All --", ""} # Translated
        selections = {
            "characters": [],
            "locations": [],
            "items": [],
            "species": [],
            "communities": [],
            "dialogues_examples": [],
            "quests": [] 
        }

        char_a_name = self.generation_panel.character_a_combo.currentText() # Updated to use generation_panel
        char_b_name = self.generation_panel.character_b_combo.currentText() # Updated to use generation_panel
        if char_a_name not in ignore_values: selections["characters"].append(char_a_name)
        if char_b_name not in ignore_values: selections["characters"].append(char_b_name)

        current_region_name = self.generation_panel.scene_region_combo.currentText() # Updated to use generation_panel
        current_sub_location_name = self.generation_panel.scene_sub_location_combo.currentText() # Updated to use generation_panel
        
        if current_sub_location_name not in ignore_values:
            selections["locations"].append(current_sub_location_name)
        elif current_region_name not in ignore_values:
            selections["locations"].append(current_region_name)

        for list_w, category_key_name in [ # Renamed variables in loop
            (self.character_list, "characters"), 
            (self.location_list, "locations"),
            (self.item_list, "items"), 
            (self.species_list, "species"),
            (self.communities_list, "communities"), 
            (self.dialogue_examples_list, "dialogues_examples") # Used renamed list
        ]:
            for i in range(list_w.count()):
                item_widget = list_w.item(i)
                if item_widget.checkState() == Qt.Checked:
                    item_text = item_widget.text()
                    if item_text not in ignore_values:
                        selections[category_key_name].append(item_text) # Renamed variable
        
        for category_key in selections:
            valid_items = []
            seen_items = set() # Renamed
            for item_name in selections[category_key]:
                if item_name not in ignore_values and item_name not in seen_items:
                    valid_items.append(item_name)
                    seen_items.add(item_name)
            selections[category_key] = valid_items
        
        return selections

    def _update_token_estimation_and_prompt_display(self):
        """Updates the token count estimation and displays the estimated prompt.

        This method is called when context selections or user instructions change.
        It builds the context, then the full prompt with PromptEngine, and updates
        the token count label and the prompt preview tab.
        """
        if not self.context_builder: return

        selected_elements = self._get_current_context_selections() # Renamed method called

        user_instruction_text = self.generation_panel.user_instruction_input.toPlainText() # Updated
        include_dialogue_type_flag = self.generation_panel.include_dialogue_type_checkbox.isChecked() # Updated
        
        MAX_TOKENS_FOR_CONTEXT_BUILDING = 32000 
        
        context_string = self.context_builder.build_context( # Renamed
            selected_elements,
            user_instruction_text, 
            max_tokens=MAX_TOKENS_FOR_CONTEXT_BUILDING, 
            include_dialogue_type=include_dialogue_type_flag
        )
        
        context_token_count = self.context_builder._count_tokens(context_string) # Renamed

        generation_parameters = {} # Renamed
        
        estimated_full_prompt_text, estimated_total_token_count = self.prompt_engine.build_prompt( # Renamed vars
            context_summary=context_string, 
            user_specific_goal=user_instruction_text,
            generation_params=generation_parameters
        )
        
        self.generation_panel.estimated_token_count_label.setText(f"Context: {context_token_count} / Total Prompt (est.): {estimated_total_token_count} tokens") # Updated

        preview_tab_title_text = "Full Prompt (Est.)" # Renamed
        if self.generation_panel.variant_display_tabs.count() == 0: # Updated
            prompt_preview_text_edit = QTextEdit() # Renamed
            prompt_preview_text_edit.setReadOnly(True)
            self.generation_panel.variant_display_tabs.addTab(prompt_preview_text_edit, preview_tab_title_text) # Updated
        else:
            self.generation_panel.variant_display_tabs.setTabText(0, preview_tab_title_text) # Updated
        
        preview_widget_item = self.generation_panel.variant_display_tabs.widget(0) # Updated
        if isinstance(preview_widget_item, QTextEdit):
            preview_widget_item.setPlainText(estimated_full_prompt_text)

    def _on_generate_dialogue_button_clicked(self): # Renamed
        """Handles the click event of the 'Generate Dialogue' button.

        Retrieves user selections, builds the context and final prompt,
        calls the LLM client to generate dialogue variants, and displays
        the prompt and variants (or errors) in tabs.
        """
        self.statusBar().showMessage("Generation in progress...")
        
        while self.generation_panel.variant_display_tabs.count() > 0: # Updated
            self.generation_panel.variant_display_tabs.removeTab(0) # Updated

        if not self.context_builder:
            self.statusBar().showMessage("ContextBuilder not initialized.")
            return

        user_instruction_text = self.generation_panel.user_instruction_input.toPlainText() # Updated
        if not user_instruction_text.strip():
            self.statusBar().showMessage("Please enter an instruction for the LLM.")
            self._update_token_estimation_and_prompt_display() 
            return
        
        selected_elements = self._get_current_context_selections() # Renamed method called

        include_dialogue_type_flag = self.generation_panel.include_dialogue_type_checkbox.isChecked() # Updated
        
        try:
            max_k_tokens_string = self.generation_panel.max_tokens_input.text().replace("k", "").replace("K", "").strip() # Updated
            max_context_tokens = int(float(max_k_tokens_string) * 1000) if max_k_tokens_string else 4000 # Renamed
            if max_context_tokens <= 0: max_context_tokens = 4000 
        except ValueError:
            max_context_tokens = 4000 
        
        context_summary_string = self.context_builder.build_context( # Renamed
            selected_elements,
            user_instruction_text, 
            max_tokens=max_context_tokens, 
            include_dialogue_type=include_dialogue_type_flag
        )

        generation_parameters = {} 
        current_llm_prompt, total_prompt_tokens = self.prompt_engine.build_prompt( # Renamed vars
            context_summary=context_summary_string,
            user_specific_goal=user_instruction_text,
            generation_params=generation_parameters
        )
        
        final_context_tokens = self.context_builder._count_tokens(context_summary_string) # Renamed
        self.generation_panel.estimated_token_count_label.setText(f"Context: {final_context_tokens} / LLM Prompt: {total_prompt_tokens} tokens") # Updated

        prompt_display_text_edit = QTextEdit() # Renamed
        prompt_display_text_edit.setReadOnly(True)
        prompt_display_text_edit.setPlainText(current_llm_prompt)
        self.generation_panel.variant_display_tabs.insertTab(0, prompt_display_text_edit, "Final Prompt (for LLM)") # Updated
        self.generation_panel.variant_display_tabs.setCurrentIndex(0) # Updated

        try:
            variant_count = int(self.generation_panel.variant_count_input.text()) # Updated
            if variant_count <= 0:
                self.statusBar().showMessage("Number of variants (k) must be positive.")
                return
        except ValueError:
            self.statusBar().showMessage("Number of variants (k) must be an integer.")
            return

        self.statusBar().showMessage(f"Generating {variant_count} variants with {type(self.llm_client).__name__}... (Prompt: {total_prompt_tokens} tokens)")
        QApplication.processEvents() 

        try:
            generated_variants = asyncio.run(self.llm_client.generate_variants(current_llm_prompt, variant_count)) # Renamed
            
            if generated_variants:
                for i, variant_text_content in enumerate(generated_variants): # Renamed
                    variant_tab_content_widget = QTextEdit() # Renamed
                    variant_tab_content_widget.setPlainText(variant_text_content)
                    variant_tab_content_widget.setReadOnly(True) 
                    self.generation_panel.variant_display_tabs.addTab(variant_tab_content_widget, f"Variant {i+1}") # Updated
                self.statusBar().showMessage(f"{len(generated_variants)} variants generated. LLM Prompt: {total_prompt_tokens} tokens.")
            else:
                self.statusBar().showMessage("No variants were generated.")

        except Exception as e:
            self.statusBar().showMessage(f"Error during generation: {e}")
            error_report_tab = QTextEdit() # Renamed
            error_report_tab.setPlainText(f"An error occurred:\n{type(e).__name__}: {e}\n\nPrompt used ({total_prompt_tokens} tokens):\n{current_llm_prompt}")
            self.generation_panel.variant_display_tabs.addTab(error_report_tab, "Error") # Updated
            logger.error(f"Error during generation: {e}", exc_info=True)

    def _filter_list_widget(self, filter_text: str, list_widget_to_filter: QListWidget, label_to_update: QLabel, original_label_text_content: str): # Renamed args
        """Filters items in a QListWidget based on input text.

        Hides items that do not match the text and updates the associated
        label to show the count of visible/total items.

        Args:
            filter_text: The text used for filtering.
            list_widget_to_filter: The QListWidget to filter.
            label_to_update: The QLabel to update with the count.
            original_label_text_content: The original text of the label (without count).
        """
        num_visible_items = 0 # Renamed
        for i in range(list_widget_to_filter.count()):
            list_item = list_widget_to_filter.item(i) # Renamed
            if list_item:
                is_hidden_by_filter = filter_text.lower() not in list_item.text().lower() # Renamed
                list_item.setHidden(is_hidden_by_filter)
                if not is_hidden_by_filter:
                    num_visible_items += 1
        total_items_count = list_widget_to_filter.count() # Renamed
        label_to_update.setText(f"{original_label_text_content} ({num_visible_items}/{total_items_count})")

    def _populate_list_widget(self, list_widget_to_populate: QListWidget, data_source_list: list, name_extraction_func, label_to_update: QLabel, original_label_text_content: str): # Renamed args
        """Populates a QListWidget with data and configures items to be checkable.
        
        Args:
            list_widget_to_populate: The QListWidget to populate.
            data_source_list: The source data list (currently unused directly).
            name_extraction_func: A callable function that returns a list of names to display.
            label_to_update: The QLabel associated with the list, for displaying count.
            original_label_text_content: The base text of the label.
        """
        # Disconnect first, before clearing or modifying the list structure
        try:
            list_widget_to_populate.itemChanged.disconnect(self._on_list_item_check_changed)
        except (TypeError, RuntimeError): 
            pass # Safe to ignore if not connected or already disconnected

        list_widget_to_populate.clear()
        item_names = [] # Renamed
        valid_item_names = [] 
        if self.context_builder and callable(name_extraction_func): 
            item_names = name_extraction_func()
        
        if item_names:
            valid_item_names = [str(name) for name in item_names if name is not None]
            for name_string in valid_item_names: # Renamed
                list_item = QListWidgetItem(name_string) # Renamed
                list_item.setFlags(list_item.flags() | Qt.ItemIsUserCheckable)
                list_item.setCheckState(Qt.Unchecked)
                list_widget_to_populate.addItem(list_item)
            label_to_update.setText(f"{original_label_text_content} ({len(valid_item_names)}/{len(valid_item_names)})")
            list_widget_to_populate.itemChanged.connect(self._on_list_item_check_changed) 
        else:
            list_widget_to_populate.addItem(QListWidgetItem("No items.")) # Translated
            label_to_update.setText(f"{original_label_text_content} (0/0)")
        if list_widget_to_populate.count() > 0:
            list_widget_to_populate.setCurrentItem(None)
        # Removed status bar message from here as it was too frequent
        self._update_token_estimation_and_prompt_display() 

    def load_initial_data(self):
        """Loads initial data into the UI lists and comboboxes.
        
        Populates lists for characters, locations, etc., as well as comboboxes
        for scene selection. Also updates the token estimation.
        """
        if not self.context_builder: return

        self._populate_list_widget(self.character_list, [], self.context_builder.get_characters_names, self.character_section_label, "Characters:")
        self._populate_list_widget(self.location_list, [], self.context_builder.get_locations_names, self.location_section_label, "Locations:")
        self._populate_list_widget(self.item_list, [], self.context_builder.get_items_names, self.item_section_label, "Items:")
        self._populate_list_widget(self.species_list, [], self.context_builder.get_species_names, self.species_section_label, "Species:")
        self._populate_list_widget(self.communities_list, [], self.context_builder.get_communities_names, self.communities_section_label, "Communities:")
        self._populate_list_widget(self.dialogue_examples_list, [], self.context_builder.get_dialogue_examples_titles, self.dialogue_examples_section_label, "Dialogue Examples:") # Used renamed list

        char_names_list = ["-- None --"] + (self.context_builder.get_characters_names() if self.context_builder else []) # Renamed
        self.generation_panel.character_a_combo.clear() # Updated
        self.generation_panel.character_a_combo.addItems(char_names_list) # Updated
        self.generation_panel.character_b_combo.clear() # Updated
        self.generation_panel.character_b_combo.addItems(char_names_list) # Updated

        region_names_list = ["-- All --"] + self.context_builder.get_regions() # Renamed, translated
        self.generation_panel.scene_region_combo.clear() # Updated
        self.generation_panel.scene_region_combo.addItems(region_names_list) # Updated
        self._on_scene_region_changed() # Call renamed slot to populate sub-locations initially
        
        self.statusBar().showMessage("Initial data loaded.") # Translated
        self._update_token_estimation_and_prompt_display() 

    def _on_scene_region_changed(self): # Renamed
        """Updates the sub-location list when the selected region changes.
        
        Called when the user modifies the selection in the regions combobox.
        Populates the sub-locations combobox with localities corresponding to the region.
        """
        if not self.context_builder: return
        
        selected_region_name = self.generation_panel.scene_region_combo.currentText() # Updated
        self.generation_panel.scene_sub_location_combo.clear() # Updated
        self.generation_panel.scene_sub_location_combo.addItem("-- None --") # Updated, Translated

        if selected_region_name and selected_region_name != "-- All --": # Translated
            sub_location_names = self.context_builder.get_sub_locations(selected_region_name) # Renamed
            if sub_location_names:
                self.generation_panel.scene_sub_location_combo.addItems(sub_location_names) # Updated

    def _on_suggest_linked_elements_clicked(self): # Renamed
        """Handles the click on the 'Select Linked Elements' button.
        
        Retrieves elements linked to Character A and/or the selected location
        via ContextBuilder, then automatically checks these elements in the
        corresponding left-hand lists.
        """
        if not self.context_builder: return

        char_a_name = self.generation_panel.character_a_combo.currentText() # Updated
        if char_a_name == "-- None --" or char_a_name == "<None>": char_a_name = None 
        
        selected_location_names = [] # Renamed
        region_name = self.generation_panel.scene_region_combo.currentText() # Updated
        sub_loc_name = self.generation_panel.scene_sub_location_combo.currentText() # Updated

        if sub_loc_name and sub_loc_name != "-- None --":
            selected_location_names.append(sub_loc_name)
        elif region_name and region_name != "-- All --" and region_name != "<None>": 
            selected_location_names.append(region_name)

        if not char_a_name and not selected_location_names:
            self.statusBar().showMessage("Please select Character A and/or a Location/Region to suggest links.") # Translated
            return

        linked_data_map = self.context_builder.get_linked_elements(char_a_name, selected_location_names) # Renamed
        
        list_widget_map = { # Renamed
            "characters": self.character_list,
            "locations": self.location_list,
            "items": self.item_list,
            "species": self.species_list,
            "communities": self.communities_list
        }

        for category_key, names_set in linked_data_map.items(): # Renamed vars
            if category_key in list_widget_map and names_set:
                list_widget = list_widget_map[category_key]
                for i in range(list_widget.count()):
                    item = list_widget.item(i)
                    if item.text() in names_set:
                        item.setCheckState(Qt.Checked)
        
        self.statusBar().showMessage("Link suggestions applied. Check the selected items.") # Translated
        self._update_token_estimation_and_prompt_display() 

    def _display_details_in_tree(self, data_to_display: dict | list): # Renamed arg
        """Displays item details in the QTreeView.

        Args:
            data_to_display: The data to display (dict or list).
        """
        self.details_tree_model.clear()
        root_item = self.details_tree_model.invisibleRootItem()
        if data_to_display:
            populate_tree_view(self.details_tree_model, root_item, data_to_display)
            self.details_tree_view.expandToDepth(0)
            self.details_tree_view.header().resizeSections(QHeaderView.ResizeToContents) 
            self.details_tree_view.header().setSectionResizeMode(0, QHeaderView.ResizeToContents) 
            self.details_tree_view.header().setSectionResizeMode(1, QHeaderView.Stretch)
        else:
            no_details_item = QStandardItem("No details to display for selection.") # Translated
            no_details_item.setEditable(False)
            self.details_tree_model.invisibleRootItem().appendRow(no_details_item)

    def _on_explorer_list_item_clicked(self, clicked_list_widget: QListWidget, category_data: list, category_singular_name: str, list_item_widget: QListWidgetItem, name_key_priority_list=None): # Renamed args
        """Handles a click on an item in one of the left explorer lists.

        Displays details of the clicked item in the central QTreeView.

        Args:
            clicked_list_widget: The QListWidget from which the click originated.
            category_data: The complete data list for this category.
            category_singular_name: The singular name of the category (e.g., "Character").
            list_item_widget: The QListWidgetItem that was clicked.
            name_key_priority_list (list, optional): List of keys to use to find
                                            the item's name in the data. 
                                            Defaults to ["Nom"].
        """
        if name_key_priority_list is None: # Renamed arg
            name_key_priority_list = ["Nom"] # "Nom" is a GDD key, kept for now
        
        self.active_list_widget_for_details = clicked_list_widget
        
        if not list_item_widget: 
            self.details_tree_model.clear() 
            self.statusBar().showMessage("No item clicked.") # Translated
            return
            
        selected_display_text = list_item_widget.text() # Renamed
        selected_item_data = None # Renamed
        
        if category_data: 
            for item_detail_dict in category_data: # Renamed
                if isinstance(item_detail_dict, dict):
                    current_item_name_from_dict = None # Renamed
                    for key_name in name_key_priority_list: # Renamed
                        if key_name in item_detail_dict:
                            value = item_detail_dict[key_name] # Renamed
                            if isinstance(value, (str, int, float)):
                               current_item_name_from_dict = str(value)
                               break 
                    if current_item_name_from_dict == selected_display_text:
                        selected_item_data = item_detail_dict
                        break
        
        self.statusBar().showMessage(f"Details for {category_singular_name}: {selected_display_text}") # Translated
        if selected_item_data:
            self._display_details_in_tree(selected_item_data)
        else:
            self.details_tree_model.clear()
            error_message_key_item = QStandardItem(f"Details not found for: {selected_display_text}") # Renamed
            error_message_key_item.setEditable(False)
            error_message_value_item = QStandardItem("") # Renamed
            error_message_value_item.setEditable(False)
            self.details_tree_model.invisibleRootItem().appendRow([error_message_key_item, error_message_value_item])
            self.statusBar().showMessage(f"Details not found for {category_singular_name}: {selected_display_text}") # Translated

    def _on_list_item_check_changed(self, list_item: QListWidgetItem): # Renamed arg
        """Called when the check state of a list item changes.

        Triggers an update of the token estimation and prompt.

        Args:
            list_item: The QListWidgetItem whose state changed.
        """
        self._update_token_estimation_and_prompt_display()

    def _get_checked_items(self, list_widget_to_check: QListWidget) -> list[str]: # Renamed arg
        """Returns a list of texts of checked items in a QListWidget.

        Args:
            list_widget_to_check: The QListWidget to inspect.

        Returns:
            A list of strings, where each string is the text
            of a checked item.
        """
        checked_item_texts = [] # Renamed
        for i in range(list_widget_to_check.count()):
            item = list_widget_to_check.item(i)
            if item and item.checkState() == Qt.Checked:
                checked_item_texts.append(item.text())
        return checked_item_texts

    def _save_ui_settings(self):
        """Saves the current state of the user interface to a JSON file.
        
        This includes window geometry, splitter panel sizes,
        selections in comboboxes, checkbox states, user instruction text,
        and checked items in lists.
        """
        ui_settings_map = { # Renamed
            "window_geometry": self.saveGeometry().data().hex(), 
            "splitter_sizes": self.main_splitter.sizes() if hasattr(self, 'main_splitter') else [], 
            "character_a_combo_text": self.generation_panel.character_a_combo.currentText(), # Updated
            "character_b_combo_text": self.generation_panel.character_b_combo.currentText(), # Updated
            "scene_region_combo_text": self.generation_panel.scene_region_combo.currentText(), # Updated
            "scene_sub_location_combo_text": self.generation_panel.scene_sub_location_combo.currentText(), # Updated
            "variant_count_input_text": self.generation_panel.variant_count_input.text(), # Updated
            "max_tokens_input_text": self.generation_panel.max_tokens_input.text(), # Updated
            "include_dialogue_type_checkbox_checked": self.generation_panel.include_dialogue_type_checkbox.isChecked(), # Updated
            "restore_selections_action_checked": self.restore_selections_action.isChecked(), 
            "user_instruction_input_text": self.generation_panel.user_instruction_input.toPlainText(), # Updated
            "checked_characters": self._get_checked_items(self.character_list),
            "checked_locations": self._get_checked_items(self.location_list),
            "checked_items": self._get_checked_items(self.item_list),
            "checked_species": self._get_checked_items(self.species_list),
            "checked_communities": self._get_checked_items(self.communities_list),
            "checked_dialogue_examples": self._get_checked_items(self.dialogue_examples_list), # Used renamed list
        }
        try:
            with open(UI_SETTINGS_FILE, "w", encoding="utf-8") as f:
                json.dump(ui_settings_map, f, indent=4)
            logger.info(f"UI settings saved to {UI_SETTINGS_FILE}") # Translated
        except Exception as e:
            logger.error(f"Error saving UI settings: {e}") # Translated

    def _load_ui_settings(self):
        """Loads and applies the user interface state from a JSON file.
        
        Restores window geometry, selections, and control states
        if the "Restore selections on startup" option is enabled.
        """
        logger.info("Attempting to load UI settings...") # Added log
        if not UI_SETTINGS_FILE.exists():
            logger.info(f"No UI settings file found at {UI_SETTINGS_FILE}. Using default values.") # Translated
            if hasattr(self, 'restore_selections_action'): 
                 self.restore_selections_action.setChecked(True)
            return

        try:
            with open(UI_SETTINGS_FILE, "r", encoding="utf-8") as f:
                loaded_settings = json.load(f) # Renamed
            logger.info(f"Successfully loaded UI settings from {UI_SETTINGS_FILE}: {loaded_settings}") # Added log
        except Exception as e:
            logger.error(f"Error loading UI settings: {e}") # Translated
            return

        self.restore_selections_action.setChecked(loaded_settings.get("restore_selections_action_checked", True))
        logger.info(f"Restore selections on startup: {self.restore_selections_action.isChecked()}") # Added log

        if not self.restore_selections_action.isChecked():
            logger.info("Restoration of selections disabled via menu.") # Translated
            if "window_geometry" in loaded_settings: self.restoreGeometry(bytes.fromhex(loaded_settings["window_geometry"])) 
            if "splitter_sizes" in loaded_settings and hasattr(self, 'main_splitter') and loaded_settings["splitter_sizes"]: self.main_splitter.setSizes(loaded_settings["splitter_sizes"]) 
            return

        if "window_geometry" in loaded_settings: self.restoreGeometry(bytes.fromhex(loaded_settings["window_geometry"])) 
        if "splitter_sizes" in loaded_settings and hasattr(self, 'main_splitter') and loaded_settings["splitter_sizes"]: self.main_splitter.setSizes(loaded_settings["splitter_sizes"]) 
        
        def set_combo_text_from_settings(combo_box: QComboBox, setting_text: str): # Renamed args
            """Selects the `setting_text` item in the `combo_box`.

            The search is first case-sensitive. If no item is found,
            a case-insensitive and space-insensitive search is attempted.
            """
            combo_name = combo_box.objectName() if combo_box.objectName() else "Unnamed ComboBox" # Get object name
            logger.debug(f"Attempting to set {combo_name} to '{setting_text}'") 
            if not setting_text:
                logger.debug(f"Empty setting_text for {combo_name}, skipping.") 
                return
            
            # Temporarily block signals to prevent unwanted updates during loading
            # signals_blocked = combo_box.blockSignals(True) # Commented out, explicit disconnect/connect is preferred
            
            idx = combo_box.findText(setting_text) 
            if idx == -1:
                logger.debug(f"'{setting_text}' not found with case-sensitive search in {combo_name}. Trying normalized search.") 
                normalized_target_text = "".join(setting_text.split()).lower() 
                for i in range(combo_box.count()):
                    candidate_text = combo_box.itemText(i) 
                    if "".join(candidate_text.split()).lower() == normalized_target_text:
                        idx = i
                        logger.debug(f"Normalized search found '{setting_text}' at index {i} in {combo_name}.") 
                        break
            if idx != -1:
                combo_box.setCurrentIndex(idx)
                logger.info(f"Successfully set {combo_name} to '{setting_text}' (index {idx}).") 
            else:
                logger.warning(f"Item '{setting_text}' not found in {combo_name} during loading.") 
            
            # Restore signals
            # if not signals_blocked: # Only unblock if we blocked them
            #     combo_box.blockSignals(False) # Commented out

        # --- Store original connections ---
        # No need to store, we will reconnect to the known methods directly.

        # --- Disconnect signals temporarily for generation comboboxes ---
        try: self.generation_panel.character_a_combo.currentIndexChanged.disconnect(self._update_token_estimation_and_prompt_display) # Updated
        except RuntimeError: pass 
        try: self.generation_panel.character_b_combo.currentIndexChanged.disconnect(self._update_token_estimation_and_prompt_display) # Updated
        except RuntimeError: pass
        try: self.generation_panel.scene_region_combo.currentIndexChanged.disconnect(self._on_scene_region_changed) # Updated
        except RuntimeError: pass
        try: self.generation_panel.scene_region_combo.currentIndexChanged.disconnect(self._update_token_estimation_and_prompt_display) # Updated
        except RuntimeError: pass
        try: self.generation_panel.scene_sub_location_combo.currentIndexChanged.disconnect(self._update_token_estimation_and_prompt_display) # Updated
        except RuntimeError: pass

        char_a_setting = loaded_settings.get("character_a_combo_text", "-- None --")
        logger.info(f"Loading Character A: '{char_a_setting}'")
        set_combo_text_from_settings(self.generation_panel.character_a_combo, char_a_setting) # Updated

        char_b_setting = loaded_settings.get("character_b_combo_text", "-- None --")
        logger.info(f"Loading Character B: '{char_b_setting}'")
        set_combo_text_from_settings(self.generation_panel.character_b_combo, char_b_setting) # Updated
        
        saved_region_text = loaded_settings.get("scene_region_combo_text", "-- All --") 
        logger.info(f"Loading Scene Region: '{saved_region_text}'")
        set_combo_text_from_settings(self.generation_panel.scene_region_combo, saved_region_text) # Updated
        
        # Manually call _on_scene_region_changed if a region was actually loaded
        # to populate sub-locations before trying to set the sub-location combo.
        current_region_idx = self.generation_panel.scene_region_combo.currentIndex() # Updated
        if current_region_idx != -1: # Ensure an item is actually selected
            region_text = self.generation_panel.scene_region_combo.itemText(current_region_idx) # Updated
            if region_text and region_text != "-- All --" and region_text != "-- None --":
                 self._on_scene_region_changed() # Call to populate sub-locations

        saved_sub_location_text = loaded_settings.get("scene_sub_location_combo_text", "-- None --") 
        logger.info(f"Loading Sub-Location: '{saved_sub_location_text}'")
        set_combo_text_from_settings(self.generation_panel.scene_sub_location_combo, saved_sub_location_text) # Updated

        # --- Reconnect signals ---
        self.generation_panel.character_a_combo.currentIndexChanged.connect(self._update_token_estimation_and_prompt_display) # Updated
        self.generation_panel.character_b_combo.currentIndexChanged.connect(self._update_token_estimation_and_prompt_display) # Updated
        self.generation_panel.scene_region_combo.currentIndexChanged.connect(self._on_scene_region_changed) # Updated
        self.generation_panel.scene_region_combo.currentIndexChanged.connect(self._update_token_estimation_and_prompt_display) # Updated
        self.generation_panel.scene_sub_location_combo.currentIndexChanged.connect(self._update_token_estimation_and_prompt_display) # Updated

        self.generation_panel.variant_count_input.setText(loaded_settings.get("variant_count_input_text", "1")) # Updated
        self.generation_panel.max_tokens_input.setText(loaded_settings.get("max_tokens_input_text", "4")) # Updated
        self.generation_panel.include_dialogue_type_checkbox.setChecked(loaded_settings.get("include_dialogue_type_checkbox_checked", True)) # Updated
        self.generation_panel.user_instruction_input.setPlainText(loaded_settings.get("user_instruction_input_text", "")) # Updated

        def set_checked_list_items(list_widget_to_update: QListWidget, checked_item_texts_list: list[str]): # Renamed args
            try: list_widget_to_update.itemChanged.disconnect() 
            except RuntimeError: pass
            for i in range(list_widget_to_update.count()):
                item = list_widget_to_update.item(i)
                if item.text() in checked_item_texts_list:
                    item.setCheckState(Qt.Checked)
                else:
                    item.setCheckState(Qt.Unchecked)
            list_widget_to_update.itemChanged.connect(self._on_list_item_check_changed)

        set_checked_list_items(self.character_list, loaded_settings.get("checked_characters", []))
        set_checked_list_items(self.location_list, loaded_settings.get("checked_locations", []))
        set_checked_list_items(self.item_list, loaded_settings.get("checked_items", []))
        set_checked_list_items(self.species_list, loaded_settings.get("checked_species", []))
        set_checked_list_items(self.communities_list, loaded_settings.get("checked_communities", []))
        set_checked_list_items(self.dialogue_examples_list, loaded_settings.get("checked_dialogue_examples", [])) # Used renamed list

        logger.info(f"UI settings loaded from {UI_SETTINGS_FILE}") # Translated
        self._update_token_estimation_and_prompt_display() 

    def closeEvent(self, close_event: QCloseEvent): # Renamed arg, QCloseEvent for type hint
        """Overrides closeEvent to save settings before exiting.

        Args:
            close_event: The close event.
        """
        self._save_ui_settings()
        super().closeEvent(close_event)

# For testing, if you run main_window.py directly (requires some adjustments)
if __name__ == '__main__':
    logging.basicConfig(level=logging.INFO, 
                        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
                        handlers=[logging.StreamHandler()]) 

    logger.info("Starting DialogueGenerator application...") # Translated
    app = QApplication(sys.argv)

    logger.info("Initializing ContextBuilder...") # Translated
    context_builder_instance = ContextBuilder() # Renamed
    context_builder_instance.load_gdd_files()
    logger.info("ContextBuilder initialized.") # Translated

    logger.info("Initializing MainWindow...") # Translated
    main_application_window = MainWindow(context_builder_instance) # Renamed
    main_application_window.show()
    logger.info("MainWindow displayed.") # Translated

    sys.exit(app.exec()) 